<HTML
><HEAD
><TITLE
>What is Smarty?</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Smarty Manual"
HREF="index"><LINK
REL="UP"
TITLE="Getting Started"
HREF="getting.started"><LINK
REL="PREVIOUS"
TITLE="Getting Started"
HREF="getting.started"><LINK
REL="NEXT"
TITLE="Installation"
HREF="installation"><META
HTTP-EQUIV="Content-type"
CONTENT="text/html; charset=ISO-8859-1"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Smarty Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="getting.started"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="installation"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="what.is.smarty"
></A
>Chapter 1. What is Smarty?</H1
><P
>&#13;   Smarty is a template engine for PHP. More specifically, it facilitates a
   manageable way to separate application logic and content from its
   presentation. This is best described in a situation where the application
   programmer and the template designer play different roles, or in most
   cases are not the same person.
  </P
><P
>&#13;   For example, let's say you are creating a web page that is displaying a
   newspaper article.
   </P
><P
></P
><UL
><LI
><P
>&#13;   The article <TT
CLASS="literal"
>$headline</TT
>, <TT
CLASS="literal"
>$tagline</TT
>,
   <TT
CLASS="literal"
>$author</TT
> and <TT
CLASS="literal"
>$body</TT
> are
   content elements, they contain no information about how they will be
   presented. They are <A
HREF="api.assign"
>passed</A
> into Smarty
   by the application.
   </P
></LI
><LI
><P
>Then the
   template designer edits the templates and uses a combination of
   HTML tags and <A
HREF="language.basic.syntax"
>template tags</A
>
   to format the presentation of these
   <A
HREF="language.syntax.variables"
>variables</A
> with elements
   such as tables, div's, background colors, font sizes, style sheets, svg etc.
   </P
></LI
><LI
><P
>One day
   the programmer needs to change the way the article content is retrieved, ie a
   change in application logic. This change does not affect the template
   designer, the content will still arrive in the template exactly the same.
   </P
></LI
><LI
><P
>&#13;   Likewise, if the template designer wants to completely redesign the
   templates, this would require no change to the application logic.
   </P
></LI
><LI
><P
>Therefore,
   the programmer can make changes to the application logic without the need
   to restructure templates, and the template designer can make changes to
   templates without breaking application logic.
  </P
></LI
></UL
><P
>&#13;   One design goal of Smarty is the separation of business logic and
   presentation logic.
   </P
><P
></P
><UL
><LI
><P
>&#13;   This means templates can certainly contain logic under
   the condition that it is for presentation only. Things such as
   <A
HREF="language.function.include"
>including</A
>
   other templates,
   <A
HREF="language.function.cycle"
>alternating</A
> table row colors,
   <A
HREF="language.modifier.upper"
>upper-casing</A
> a variable,
   <A
HREF="language.function.foreach"
>looping</A
>
   over an array of data and <A
HREF="api.display"
>displaying</A
> it
   are  examples of  presentation logic.
   </P
></LI
><LI
><P
>&#13;   This does not mean however that Smarty forces a separation of
   business and presentation logic. Smarty has no knowledge of which is which,
   so placing business logic in the template is your own doing.
    </P
></LI
><LI
><P
>Also, if you
   desire <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>no</I
></SPAN
> logic in your templates you certainly can
   do so by boiling the content down to text and variables only.
  </P
></LI
></UL
><P
>&#13;   One of the unique aspects about Smarty is the template compiling. This
   means Smarty reads the template files and creates PHP scripts from them.
   Once they are created, they are executed from then on. Therefore there is
   no costly template file parsing for each request. Each template can
   take full advantage of PHP compiler and  cache solutions such as
   <A
HREF="http://eaccelerator.net/"
TARGET="_top"
>eAccelerator</A
>,
   <A
HREF="http://www.php-accelerator.co.uk"
TARGET="_top"
>ionCube</A
>
   <A
HREF="http://turck-mmcache.sourceforge.net/"
TARGET="_top"
>mmCache</A
>
   or <A
HREF="http://www.zend.com/"
TARGET="_top"
>Zend Accelerator</A
>
   to name a few.
  </P
><P
>&#13;   <SPAN
CLASS="bold"
><B
CLASS="emphasis"
>Some of Smarty's features:</B
></SPAN
>
  </P
><P
></P
><UL
><LI
><P
>&#13;     It is extremely fast.
    </P
></LI
><LI
><P
>&#13;     It is efficient since the PHP parser does the dirty work.
    </P
></LI
><LI
><P
>&#13;     No template parsing overhead, only compiles once.
    </P
></LI
><LI
><P
>&#13;     It is smart about <A
HREF="variable.compile.check"
>recompiling</A
>
     only the template files that have changed.
    </P
></LI
><LI
><P
>&#13;     You can easily create your own custom <A
HREF="language.custom.functions"
>functions</A
>
     and <A
HREF="language.modifiers"
>variable modifiers</A
>, so the
     template language is extremely extensible.
    </P
></LI
><LI
><P
>&#13;     Configurable template
     <A
HREF="variable.left.delimiter"
>{delimiter}</A
> tag
      syntax, so you can use
     <TT
CLASS="literal"
>{$foo}</TT
>, <TT
CLASS="literal"
>{{$foo}}</TT
>,
     <TT
CLASS="literal"
>&#60;!--{$foo}--&#62;</TT
>, etc.
    </P
></LI
><LI
><P
>&#13;     The <A
HREF="language.function.if"
>&#13;     <TT
CLASS="literal"
>{if}..{elseif}..{else}..{/if}</TT
></A
>
     constructs are passed to the
     PHP parser, so the <TT
CLASS="literal"
>{if...}</TT
> expression syntax can be as
     simple or as complex an evaluation as you like.
    </P
></LI
><LI
><P
>&#13;     Allows unlimited nesting of <A
HREF="language.function.section"
>&#13;     <TT
CLASS="varname"
>sections</TT
></A
>, <TT
CLASS="varname"
>if's</TT
> etc.
    </P
></LI
><LI
><P
>&#13;     It is possible to
     <A
HREF="language.function.php"
>embed PHP code</A
>
     right in your template files, although
     this may not be needed (nor recommended) since the engine is so
     <A
HREF="plugins"
>customizable</A
>.
    </P
></LI
><LI
><P
>&#13;     Built-in <A
HREF="caching"
>caching</A
> support
    </P
></LI
><LI
><P
>&#13;     Arbitrary <A
HREF="template.resources"
>template</A
> sources
    </P
></LI
><LI
><P
>&#13;     Custom <A
HREF="section.template.cache.handler.func"
>cache handling</A
>
     functions
    </P
></LI
><LI
><P
>&#13;     <A
HREF="plugins"
>Plugin</A
> architecture
    </P
></LI
></UL
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="getting.started"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="installation"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Getting Started</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="getting.started"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Installation</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>